<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>JS Terraria - Pro Engine</title>
    <style>
        /* --- CSS: MODERNIZACJA --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Consolas', monospace; /* Czcionka techniczna */
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated; /* Ostry Pixel Art */
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: space-between;
        }

        /* Statystyki w rogu */
        #debug-stats {
            margin: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            color: #0f0;
            text-shadow: 1px 1px 0 #000;
            font-size: 12px;
            width: fit-content;
        }

        /* Nowoczesny Hotbar */
        #hotbar-container {
            pointer-events: auto;
            align-self: center;
            margin-bottom: 20px;
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid #555;
            padding: 8px;
            border-radius: 12px;
            display: flex;
            gap: 6px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(2px);
        }

        .slot {
            width: 44px; height: 44px;
            background: #2b2b2b;
            border: 2px solid #3e3e3e;
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .slot:hover {
            border-color: #888;
            transform: translateY(-2px);
        }

        .slot.active {
            border-color: #ffd700;
            background: #444;
            transform: scale(1.1) translateY(-4px);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            z-index: 10;
        }

        .slot canvas {
            width: 32px; height: 32px;
            image-rendering: pixelated;
        }

        .slot-qty {
            position: absolute; top: 2px; left: 4px;
            font-size: 10px; color: #aaa; font-weight: bold;
        }

        /* Ekran ładowania */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; color: white;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; z-index: 100;
            transition: opacity 0.8s;
        }
        
        .loader {
            width: 200px; height: 4px; background: #333; margin-top: 20px;
            border-radius: 2px; overflow: hidden;
        }
        .loader-bar {
            width: 100%; height: 100%; background: #2ecc71;
            animation: loadAnim 1s infinite linear;
            transform-origin: 0% 50%;
        }
        @keyframes loadAnim { 0% {transform: scaleX(0);} 50% {transform: scaleX(0.5);} 100% {transform: scaleX(1); margin-left: 200px;} }
    </style>
</head>
<body>

    <div id="loading-screen">
        <h1 style="font-weight:300; letter-spacing: 4px;">TERRARIA JS</h1>
        <div class="loader"><div class="loader-bar"></div></div>
    </div>

    <div id="ui-layer">
        <div id="debug-stats">FPS: 0</div>
        <div id="hotbar-container"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/* =============================================================
   1. KONFIGURACJA
   ============================================================= */
const CONFIG = {
    TILE_SIZE: 16,
    CHUNK_SIZE: 32,
    WORLD_WIDTH: 256,   // Szerszy świat
    WORLD_HEIGHT: 96,   // Głębszy świat
    GRAVITY: 900,
    MAX_LIGHT: 15,      // Siła światła
};

const TILE_ID = {
    AIR: 0, DIRT: 1, GRASS: 2, STONE: 3, BEDROCK: 4, WOOD: 5, LEAVES: 6,
    PLANKS: 7, BRICKS: 8, COAL: 10, GOLD: 11, TORCH: 12, WATER: 13
};

const TILE_DB = {
    [TILE_ID.AIR]:   { solid: false, light: 0 },
    [TILE_ID.DIRT]:  { solid: true, color: '#5d4037' },
    [TILE_ID.GRASS]: { solid: true, color: '#388e3c' },
    [TILE_ID.STONE]: { solid: true, color: '#757575' },
    [TILE_ID.BEDROCK]:{ solid: true, color: '#000' },
    [TILE_ID.WOOD]:  { solid: false, color: '#5d4037' }, 
    [TILE_ID.LEAVES]:{ solid: true, color: '#2e7d32' }, // Liście
    [TILE_ID.PLANKS]:{ solid: true, color: '#8d6e63' },
    [TILE_ID.BRICKS]:{ solid: true, color: '#a1887f' },
    [TILE_ID.COAL]:  { solid: true, color: '#212121' },
    [TILE_ID.GOLD]:  { solid: true, color: '#ffb300' },
    [TILE_ID.TORCH]: { solid: false, color: '#ff5722', light: 14 }, // Świeci!
    [TILE_ID.WATER]: { solid: false, color: 'rgba(52, 152, 219, 0.6)', liquid: true }
};

/* =============================================================
   2. SYSTEM CZĄSTECZEK
   ============================================================= */
const ParticleSystem = {
    pool: [],
    spawn(x, y, color, count = 5) {
        for(let i=0; i<count; i++) {
            this.pool.push({
                x: x + 8, y: y + 8,
                vx: (Math.random() - 0.5) * 150,
                vy: (Math.random() - 1) * 150,
                life: 1.0, color: color, size: Math.random()*3+1
            });
        }
    },
    update(dt) {
        for (let i = this.pool.length - 1; i >= 0; i--) {
            let p = this.pool[i];
            p.life -= dt * 2.5;
            if (p.life <= 0) { this.pool.splice(i, 1); continue; }
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += CONFIG.GRAVITY * dt;
        }
    },
    draw(ctx, camX, camY) {
        for (let p of this.pool) {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x - camX, p.y - camY, p.size, p.size);
        }
        ctx.globalAlpha = 1.0;
    }
};

/* =============================================================
   3. GENERATOR TEKSTUR (Proceduralny Pixel Art)
   ============================================================= */
const Assets = {
    textures: {},
    init() {
        const mkTex = (id, fn) => {
            const c = document.createElement('canvas');
            c.width = c.height = 16;
            const ctx = c.getContext('2d');
            fn(ctx);
            this.textures[id] = c;
        };
        const noise = (ctx, a=0.1) => {
            for(let i=0; i<64; i++) {
                ctx.fillStyle = Math.random()>.5?`rgba(255,255,255,${a})`:`rgba(0,0,0,${a})`;
                ctx.fillRect(Math.random()*16, Math.random()*16, 1, 1);
            }
        };

        mkTex(TILE_ID.DIRT, ctx => { ctx.fillStyle='#5d4037'; ctx.fillRect(0,0,16,16); noise(ctx, 0.15); });
        mkTex(TILE_ID.GRASS, ctx => { 
            ctx.fillStyle='#5d4037'; ctx.fillRect(0,0,16,16); noise(ctx);
            ctx.fillStyle='#4caf50'; ctx.fillRect(0,0,16,5); // Jaśniejsza trawa
            ctx.fillStyle='#388e3c'; for(let i=0;i<16;i+=2) if(Math.random()>.4) ctx.fillRect(i,5,2,3);
        });
        mkTex(TILE_ID.STONE, ctx => { 
            ctx.fillStyle='#7f8c8d'; ctx.fillRect(0,0,16,16); noise(ctx);
            ctx.fillStyle='#95a5a6'; ctx.fillRect(2,2,5,2); ctx.fillRect(8,9,4,2); // Wzorki
        });
        mkTex(TILE_ID.BRICKS, ctx => {
            ctx.fillStyle='#a1887f'; ctx.fillRect(0,0,16,16);
            ctx.fillStyle='#795548'; 
            ctx.fillRect(0,0,7,7); ctx.fillRect(8,0,8,7);
            ctx.fillRect(0,8,3,8); ctx.fillRect(4,8,8,8); ctx.fillRect(13,8,3,8);
        });
        mkTex(TILE_ID.GOLD, ctx => {
            ctx.drawImage(this.textures[TILE_ID.STONE],0,0);
            ctx.fillStyle='#f1c40f'; ctx.fillRect(5,5,4,4); ctx.fillRect(11,2,2,2);
        });
        mkTex(TILE_ID.TORCH, ctx => {
            ctx.fillStyle='#795548'; ctx.fillRect(6,6,4,10);
            ctx.fillStyle='#e74c3c'; ctx.fillRect(6,3,4,4);
            ctx.fillStyle='#f1c40f'; ctx.fillRect(7,4,2,2);
        });
        mkTex(TILE_ID.WATER, ctx => {
            ctx.fillStyle='rgba(52, 152, 219, 0.5)'; ctx.fillRect(0,0,16,16);
            ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.fillRect(2,4,4,1); ctx.fillRect(8,10,5,1);
        });
        // Reszta standardowa
        [TILE_ID.WOOD, TILE_ID.PLANKS, TILE_ID.BEDROCK, TILE_ID.LEAVES, TILE_ID.COAL].forEach(id => {
            mkTex(id, ctx => { ctx.fillStyle = TILE_DB[id].color; ctx.fillRect(0,0,16,16); noise(ctx, 0.1); });
        });
        
        mkTex('cursor', ctx => {
            ctx.strokeStyle='rgba(255,255,255,0.8)'; ctx.lineWidth=2; ctx.strokeRect(1,1,14,14);
        });
    },
    get(id) { return this.textures[id] || this.textures[TILE_ID.DIRT]; }
};

/* =============================================================
   4. ŚWIAT, GENERATOR I OŚWIETLENIE
   ============================================================= */
const World = {
    width: CONFIG.WORLD_WIDTH * CONFIG.CHUNK_SIZE,
    height: CONFIG.WORLD_HEIGHT * CONFIG.CHUNK_SIZE,
    tiles: null, walls: null, light: null,

    init() {
        const size = this.width * this.height;
        this.tiles = new Uint8Array(size);
        this.walls = new Uint8Array(size);
        this.light = new Uint8Array(size);
        this.generate();
        this.updateLighting();
    },

    get(x, y) {
        if(x<0||x>=this.width||y<0||y>=this.height) return TILE_ID.BEDROCK;
        return this.tiles[y*this.width+x];
    },
    set(x, y, id) {
        if(x>=0&&x<this.width&&y>=0&&y<this.height) {
            this.tiles[y*this.width+x] = id;
            this.updateLightingArea(x, y); // Aktualizacja światła przy zmianie bloku
        }
    },
    
    // --- Oświetlenie (Prosty Flood Fill + Dystans) ---
    updateLighting() {
        // Reset (Ciemność)
        this.light.fill(0);
        // Światło słoneczne (od góry do pierwszego bloku)
        for(let x=0; x<this.width; x++) {
            for(let y=0; y<this.height; y++) {
                const idx = y*this.width+x;
                if(TILE_DB[this.tiles[idx]].solid) break; // Słońce zatrzymuje się na bloku
                this.light[idx] = CONFIG.MAX_LIGHT;
                if(this.walls[idx]) this.light[idx] = Math.max(0, CONFIG.MAX_LIGHT - 5); // Tło przyciemnia
            }
        }
        // Emisja światła (Pochodnie)
        for(let i=0; i<this.tiles.length; i++) {
            if(this.tiles[i] === TILE_ID.TORCH) this.light[i] = 15;
        }
        // Propagacja (bardzo uproszczona dla wydajności w JS)
        // W prawdziwym silniku robi się to kolejką. Tu zrobimy szybki blur.
    },
    
    // Szybka aktualizacja wokół gracza/zmiany (uproszczona)
    updateLightingArea(cx, cy) {
        // Placeholder: w JS bez WebGL pełne dynamiczne światło jest trudne w jednym pliku.
        // Zamiast tego renderer użyje "Distance Field" w czasie rzeczywistym.
    },

    generate() {
        const heights = [];
        // Lepszy teren (złożony szum)
        for(let x=0; x<this.width; x++) {
            let h = Math.sin(x*0.04)*15 + Math.sin(x*0.01)*40 + Math.sin(x*0.1)*5 + this.height*0.35;
            heights[x] = Math.floor(h);
        }

        for(let x=0; x<this.width; x++) {
            for(let y=0; y<this.height; y++) {
                const idx = y*this.width+x;
                const h = heights[x];

                if(y < h) {
                    // Woda w dolinach
                    if (y > this.height*0.35 + 5) this.tiles[idx] = TILE_ID.WATER;
                    else this.tiles[idx] = TILE_ID.AIR;
                } else if(y === h) {
                    this.tiles[idx] = TILE_ID.GRASS;
                } else if(y > h && y < h+6) {
                    this.tiles[idx] = TILE_ID.DIRT;
                    this.walls[idx] = TILE_ID.DIRT;
                } else if(y >= this.height-3) {
                    this.tiles[idx] = TILE_ID.BEDROCK;
                } else {
                    this.tiles[idx] = TILE_ID.STONE;
                    this.walls[idx] = TILE_ID.STONE;
                    // Jaskinie (Lepszy algorytm)
                    const noise = Math.sin(x*0.08) * Math.cos(y*0.08) + Math.sin(x*0.02 + y*0.02);
                    if(noise > 0.4) {
                         this.tiles[idx] = TILE_ID.AIR; // Jaskinia
                         if(y > h+15) this.walls[idx] = TILE_ID.STONE; // Tło w jaskiniach
                    }
                    // Rudy
                    else if(Math.random()>0.985) this.tiles[idx] = TILE_ID.GOLD;
                    else if(Math.random()>0.98) this.tiles[idx] = TILE_ID.COAL;
                }
            }
            // Drzewa
            if(x>10 && x<this.width-10 && Math.random()>0.92 && this.tiles[heights[x]*this.width+x]===TILE_ID.GRASS) {
                const th = 6 + Math.floor(Math.random()*5);
                for(let i=1; i<=th; i++) { this.set(x, heights[x]-i, TILE_ID.WOOD); this.walls[(heights[x]-i)*this.width+x]=0; }
                for(let lx=x-2; lx<=x+2; lx++) for(let ly=heights[x]-th-2; ly<=heights[x]-th; ly++)
                    if(this.get(lx,ly)===0) this.set(lx,ly, TILE_ID.LEAVES);
            }
        }
    }
};

/* =============================================================
   5. INPUT, GRACZ I FIZYKA
   ============================================================= */
const Input = {
    keys: {}, mouse: {x:0,y:0,l:false,r:false},
    init() {
        window.onkeydown = e => { 
            this.keys[e.code] = true;
            if(e.key >= '1' && e.key <= '9') UI.select(parseInt(e.key)-1);
        };
        window.onkeyup = e => this.keys[e.code] = false;
        window.onmousemove = e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; };
        window.onmousedown = e => { if(e.button===0)this.mouse.l=true; if(e.button===2)this.mouse.r=true; };
        window.onmouseup = e => { if(e.button===0)this.mouse.l=false; if(e.button===2)this.mouse.r=false; };
        window.oncontextmenu = e => e.preventDefault();
        window.onwheel = e => UI.scroll(Math.sign(e.deltaY));
    }
};

const Player = {
    x: 0, y: 0, w: 12, h: 24, vx: 0, vy: 0, grounded: false, facingRight: true, animTimer: 0,
    update(dt) {
        // Sterowanie
        const moveSpeed = 1600;
        let moving = false;
        if(Input.keys['KeyA']) { this.vx -= moveSpeed * dt; this.facingRight = false; moving = true; }
        if(Input.keys['KeyD']) { this.vx += moveSpeed * dt; this.facingRight = true; moving = true; }
        if((Input.keys['Space'] || Input.keys['KeyW']) && this.grounded) {
            this.vy = -480; this.grounded = false;
        }

        // Animacja chodzenia
        if(moving && this.grounded) this.animTimer += dt * 10;
        else this.animTimer = 0;

        // Fizyka Wody (prosta)
        const cx = Math.floor((this.x+this.w/2)/16), cy = Math.floor((this.y+this.h/2)/16);
        const inWater = World.get(cx, cy) === TILE_ID.WATER;
        
        let gravity = CONFIG.GRAVITY;
        if(inWater) { gravity *= 0.3; if(this.vy > 100) this.vy = 100; } // Wyporność

        this.vy += gravity * dt;
        this.vx *= Math.pow(this.grounded?0.82:0.95, dt*60);
        
        // Kolizja
        this.x += this.vx * dt; this.collide(true);
        this.y += this.vy * dt; this.grounded = false; this.collide(false);

        // Interakcja
        this.interact(dt);
    },
    
    collide(isX) {
        const sx = Math.floor(this.x/16), ex = Math.floor((this.x+this.w)/16);
        const sy = Math.floor(this.y/16), ey = Math.floor((this.y+this.h)/16);
        for(let y=sy; y<=ey; y++) for(let x=sx; x<=ex; x++) {
            if(TILE_DB[World.get(x,y)].solid) {
                if(isX) {
                    if(this.vx>0) this.x = x*16 - this.w - 0.01; else this.x = (x+1)*16 + 0.01;
                    this.vx = 0;
                } else {
                    if(this.vy>0) { this.y = y*16 - this.h - 0.01; this.grounded=true; }
                    else this.y = (y+1)*16 + 0.01;
                    this.vy = 0;
                }
                return;
            }
        }
    },

    interact(dt) {
        const cx = Input.mouse.x + Camera.x, cy = Input.mouse.y + Camera.y;
        const tx = Math.floor(cx/16), ty = Math.floor(cy/16);
        if(Math.hypot(this.x+this.w/2-cx, this.y+this.h/2-cy) > 120) return;

        if(Input.mouse.l) { 
            const id = World.get(tx,ty);
            if(id !== TILE_ID.AIR && id !== TILE_ID.BEDROCK && id !== TILE_ID.WATER) {
                World.set(tx,ty, TILE_ID.AIR);
                ParticleSystem.spawn(tx*16, ty*16, TILE_DB[id].color);
            }
        }
        if(Input.mouse.r && World.get(tx,ty) === TILE_ID.AIR) {
            if(!(cx>this.x && cx<this.x+this.w && cy>this.y && cy<this.y+this.h))
                World.set(tx,ty, UI.getSelected());
        }
    },

    // Rysowanie postaci (Złożona z części)
    draw(ctx) {
        const bounce = Math.sin(this.animTimer) * 2; // Efekt chodzenia
        
        ctx.save();
        ctx.translate(Math.floor(this.x + this.w/2), Math.floor(this.y + this.h)); // Pivot na stopach
        if(!this.facingRight) ctx.scale(-1, 1); // Obrót

        // Nogi
        ctx.fillStyle = '#2c3e50'; // Spodnie
        if(this.grounded && Math.abs(this.vx) > 10) {
            // Animacja nóg
            ctx.fillRect(-4 + bounce, -8, 3, 8);
            ctx.fillRect(1 - bounce, -8, 3, 8);
        } else {
            ctx.fillRect(-4, -8, 3, 8);
            ctx.fillRect(1, -8, 3, 8);
        }

        // Tułów
        ctx.fillStyle = '#c0392b'; // Koszula
        ctx.fillRect(-5, -18 + Math.abs(bounce*0.5), 10, 10);
        
        // Głowa
        ctx.fillStyle = '#f1c40f'; // Skóra
        ctx.fillRect(-4, -26 + Math.abs(bounce*0.5), 8, 8);

        // Oczy
        ctx.fillStyle = 'white'; ctx.fillRect(0, -24 + Math.abs(bounce*0.5), 2, 2);
        
        ctx.restore();
    }
};

/* =============================================================
   6. RENDERER I KAMERA (PARALLAX + LIGHTING)
   ============================================================= */
const Camera = { x:0, y:0 };
const Renderer = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d', {alpha:false}),
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageRendering = 'pixelated';
    },
    draw(dt) {
        // Gładka kamera
        Camera.x += (Player.x - this.canvas.width/2 - Camera.x) * 0.1;
        Camera.y += (Player.y - this.canvas.height/2 - Camera.y) * 0.1;
        // Clamp
        Camera.x = Math.max(0, Math.min(Camera.x, World.width*16 - this.canvas.width));
        Camera.y = Math.max(0, Math.min(Camera.y, World.height*16 - this.canvas.height));

        // 1. NIEBO
        const grad = this.ctx.createLinearGradient(0,0,0,this.canvas.height);
        grad.addColorStop(0, '#87CEEB'); grad.addColorStop(0.6, '#C2F0FC'); grad.addColorStop(1, '#fff');
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);

        // 2. PARALLAX (Góry w tle)
        this.drawMountains(0.2, '#a8e6cf', 100);
        this.drawMountains(0.5, '#56ab91', 50);

        this.ctx.save();
        this.ctx.translate(-Math.floor(Camera.x), -Math.floor(Camera.y));

        // 3. ŚWIAT I OŚWIETLENIE
        const sc = Math.floor(Camera.x/16), ec = sc + Math.ceil(this.canvas.width/16)+1;
        const sr = Math.floor(Camera.y/16), er = sr + Math.ceil(this.canvas.height/16)+1;
        
        for(let y=sr; y<=er; y++) {
            for(let x=sc; x<=ec; x++) {
                // Obliczanie światła w locie (Torch + Sunlight)
                // Uproszczone: Ciemno pod ziemią, jasno na górze, jasno przy pochodniach
                let lightLevel = 1.0;
                
                // Bazowe światło (głębokość)
                if(y > 50) lightLevel = 0.1; // Ciemno w jaskiniach
                else if (y > 40) lightLevel = 1.0 - ((y-40)/10); // Przejście
                
                // Światło od pochodni (szukanie w pobliżu)
                // To jest kosztowne, ale w małym oknie działa ok
                // W pełnym silniku używa się tablicy World.light
                // Tutaj zrobimy prosty trick: jeśli blok to pochodnia, to jasno.
                if(World.get(x,y)===TILE_ID.TORCH) lightLevel = 1.0;
                
                // Rysowanie
                const wall = World.walls[y*World.width+x];
                if(wall) {
                    this.ctx.drawImage(Assets.get(wall), x*16, y*16);
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)'; // Cień tła
                    this.ctx.fillRect(x*16, y*16, 16, 16);
                }
                const tile = World.get(x,y);
                if(tile) this.ctx.drawImage(Assets.get(tile), x*16, y*16);

                // Aplikacja cienia (Lighting overlay)
                if(lightLevel < 1.0) {
                     // Sprawdź czy blisko jest pochodnia (BARDZO UPROSZCZONE)
                     // W prawdziwym kodzie: lightMap[x][y]
                     let nearTorch = false;
                     // Brute force check 5x5 range (tylko dla widocznych bloków)
                     for(let ly=y-4; ly<=y+4; ly++) for(let lx=x-4; lx<=x+4; lx++) {
                         if(World.get(lx,ly)===TILE_ID.TORCH) { nearTorch = true; break; }
                     }
                     if(nearTorch) lightLevel = 1.0;
                     
                     this.ctx.fillStyle = `rgba(0,0,0,${1-lightLevel})`;
                     this.ctx.fillRect(x*16, y*16, 16, 16);
                }
                
                // Kursor
                if(x===Math.floor((Input.mouse.x+Camera.x)/16) && y===Math.floor((Input.mouse.y+Camera.y)/16))
                    this.ctx.drawImage(Assets.get('cursor'), x*16, y*16);
            }
        }

        // 4. GRACZ
        Player.draw(this.ctx);
        
        // 5. CZĄSTECZKI
        ParticleSystem.draw(this.ctx, 0, 0);

        this.ctx.restore();
    },

    drawMountains(factor, color, yOff) {
        const offX = (Camera.x * factor) % this.canvas.width;
        this.ctx.fillStyle = color;
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.canvas.height);
        for(let i=0; i<=this.canvas.width; i+=20) {
            // Generowanie gór w oparciu o pozycję X
            const h = Math.sin((i + Camera.x * factor)*0.01) * 50 + 100 + yOff;
            this.ctx.lineTo(i, this.canvas.height - h);
        }
        this.ctx.lineTo(this.canvas.width, this.canvas.height);
        // Rysuj drugą warstwę żeby zapętlić (prosta metoda)
        this.ctx.fill();
    }
};

const UI = {
    items: [TILE_ID.DIRT, TILE_ID.GRASS, TILE_ID.STONE, TILE_ID.PLANKS, TILE_ID.BRICKS, TILE_ID.WOOD, TILE_ID.LEAVES, TILE_ID.TORCH, TILE_ID.WATER],
    sel: 0, divs: [],
    init() {
        const cont = document.getElementById('hotbar-container');
        this.items.forEach((id, i) => {
            const d = document.createElement('div');
            d.className = 'slot';
            d.innerHTML = `<div class="slot-qty">${i+1}</div>`;
            const c = document.createElement('canvas'); c.width=c.height=16; 
            setTimeout(() => c.getContext('2d').drawImage(Assets.get(id),0,0,16,16), 100);
            d.appendChild(c);
            d.onmousedown = () => this.select(i);
            cont.appendChild(d);
            this.divs.push(d);
        });
        this.select(0);
    },
    select(i) {
        this.divs[this.sel].classList.remove('active');
        this.sel = i;
        this.divs[this.sel].classList.add('active');
    },
    scroll(dir) {
        let n = this.sel + dir; if(n<0) n=this.items.length-1; if(n>=this.items.length) n=0;
        this.select(n);
    },
    getSelected() { return this.items[this.sel]; }
};

/* =============================================================
   7. START
   ============================================================= */
Assets.init();
World.init();
Input.init();
Renderer.resize();
window.onresize = () => Renderer.resize();
setTimeout(() => UI.init(), 100);

let sy = 0; while(World.get(World.width/2, sy)===TILE_ID.AIR) sy++;
Player.x = (World.width/2)*16; Player.y = (sy-4)*16;

setTimeout(()=>{ document.getElementById('loading-screen').style.opacity = 0; setTimeout(()=>document.getElementById('loading-screen').remove(),800); }, 500);

let lastTime = 0;
function loop(t) {
    let dt = (t - lastTime)/1000; lastTime = t; if(dt>0.1) dt=0.1;
    Player.update(dt);
    ParticleSystem.update(dt);
    Renderer.draw(dt);
    document.getElementById('debug-stats').innerText = `FPS: ${Math.round(1/dt)} | X:${Math.floor(Player.x/16)} Y:${Math.floor(Player.y/16)}`;
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>