<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Three.js â€” Ulepszony teren, chodzenie, kolizje, fizyka</title>
  <style>body{margin:0;overflow:hidden;font-family:Arial} #ui{position:absolute;left:10px;top:10px;color:#fff;z-index:2}</style>
</head>
<body>
<div id="ui">Click to lock pointer. WASD + mouse. Space jump. Shift sprint. R recenter.</div>

<!-- three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>

<script>
/* ================== Ustawienia ================== */
const SEED = 'kornel-seed';
const OCTAVES = 10;
const VERT_SPACING = 3;
const CHUNK_VERT_HI = 33;
const CHUNK_VERT_LO = 17;
const CHUNK_RADIUS = 3;
const LOD_DIST = 2;
const WATER_LEVEL = -2;
const GRAVITY = -40;
const PLAYER_HEIGHT = 1.8;
const PLAYER_RADIUS = 0.4;

/* ================ Scena, kamera, renderer ================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.FogExp2(0x87ceeb, 0.0006);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ================ Lights ================ */
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(120, 200, 80);
dir.castShadow = true;
dir.shadow.camera.left = -300; dir.shadow.camera.right = 300;
dir.shadow.camera.top = 300; dir.shadow.camera.bottom = -300;
dir.shadow.mapSize.set(2048,2048);
scene.add(dir);
scene.add(new THREE.AmbientLight(0x999999));

/* ================ Controls & Player state ================ */
const controls = new THREE.PointerLockControls(camera, renderer.domElement);
document.body.addEventListener('click', ()=> controls.lock());
scene.add(controls.getObject());

const keys = {w:0,s:0,a:0,d:0,shift:0};
let canJump = false;
let velocity = new THREE.Vector3();
let onGround = false;
let sprint = false;

document.addEventListener('keydown', e=>{
  if(e.code==='KeyW') keys.w=1;
  if(e.code==='KeyS') keys.s=1;
  if(e.code==='KeyA') keys.a=1;
  if(e.code==='KeyD') keys.d=1;
  if(e.code==='ShiftLeft') keys.shift=1;
  if(e.code==='Space' && onGround){ velocity.y = 14; onGround=false; canJump=false; }
  if(e.code==='KeyR') controls.getObject().position.set(0,80,0);
});
document.addEventListener('keyup', e=>{
  if(e.code==='KeyW') keys.w=0;
  if(e.code==='KeyS') keys.s=0;
  if(e.code==='KeyA') keys.a=0;
  if(e.code==='KeyD') keys.d=0;
  if(e.code==='ShiftLeft') keys.shift=0;
});

/* ================ Noise worker (inline) ================ */
const workerCode = `
self.importScripts('https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js');
let simplex = new SimplexNoise('` + SEED + `');
const OCTAVES = ${OCTAVES};
self.onmessage = function(e){
  const {taskId, cx, cz, nVerts, vertSpacing} = e.data;
  const size = (nVerts-1) * vertSpacing;
  const positions = new Float32Array(nVerts * nVerts * 3);
  let idx = 0;
  function getHeight(x,z){
    let total=0, freq=0.0025, amp=60, persistence=0.5, lac=2.0;
    for(let i=0;i<OCTAVES;i++){
      total += simplex.noise2D(x*freq, z*freq) * amp;
      amp *= persistence; freq *= lac;
    }
    return total * 0.6;
  }
  for(let j=0;j<nVerts;j++){
    for(let i=0;i<nVerts;i++){
      const vx = (i - (nVerts-1)/2) * vertSpacing + cx * size;
      const vz = (j - (nVerts-1)/2) * vertSpacing + cz * size;
      const y = getHeight(vx, vz);
      positions[idx++] = vx;
      positions[idx++] = y;
      positions[idx++] = vz;
    }
  }
  self.postMessage({taskId, cx, cz, nVerts, positions}, [positions.buffer]);
};
`;
const blob = new Blob([workerCode], {type:'application/javascript'});
const worker = new Worker(URL.createObjectURL(blob));
let workerTasks = new Map();
let nextTaskId = 1;
worker.onmessage = function(e){
  const {taskId, cx, cz, nVerts, positions} = e.data;
  const cb = workerTasks.get(taskId);
  if(cb) cb({cx,cz,nVerts,positions});
  workerTasks.delete(taskId);
};

/* ================ Chunk system, pooling, LOD ================ */
const chunkMap = new Map();
const meshPool = [];

function chunkKey(cx,cz){ return cx + ',' + cz; }

function createPlaneGeometry(nVerts){
  const size = (nVerts-1) * VERT_SPACING;
  const geom = new THREE.PlaneBufferGeometry(size, size, nVerts-1, nVerts-1);
  geom.rotateX(-Math.PI/2);
  return geom;
}

function getPooledMesh(nVerts, material){
  for(let i=0;i<meshPool.length;i++){
    const m = meshPool[i];
    if(m.userData.nVerts === nVerts){
      meshPool.splice(i,1);
      m.material = material;
      m.visible = true;
      return m;
    }
  }
  const geom = createPlaneGeometry(nVerts);
  const mesh = new THREE.Mesh(geom, material);
  mesh.castShadow = false;
  mesh.receiveShadow = true;
  mesh.userData.nVerts = nVerts;
  return mesh;
}
function releaseMesh(mesh){
  mesh.visible = false;
  scene.remove(mesh);
  meshPool.push(mesh);
}

/* Materials (simple PBR-like) */
const groundMatHi = new THREE.MeshStandardMaterial({color:0x6b8e23, roughness:0.9, metalness:0.0});
const groundMatLo = new THREE.MeshStandardMaterial({color:0x6b8e23, roughness:1.0, flatShading:true});
const rockMat = new THREE.MeshStandardMaterial({color:0x7a7a7a, roughness:0.8});
const waterMat = new THREE.MeshStandardMaterial({color:0x1e90ff, transparent:true, opacity:0.6, roughness:0.3});

/* Instanced trees */
const treeGeom = new THREE.ConeGeometry(1.2, 4, 6);
const trunkGeom = new THREE.CylinderGeometry(0.3,0.3,1.2,6);
const treeMat = new THREE.MeshStandardMaterial({color:0x1b5e20});
const trunkMat = new THREE.MeshStandardMaterial({color:0x6b3a1a});
const treeCountPerChunk = 40;
const instancedTrees = new Map(); // key -> {instMesh, trunkInst}

/* generate chunk via worker */
function requestChunk(cx, cz, lod){
  const key = chunkKey(cx,cz);
  if(chunkMap.has(key)) return;
  const nVerts = (lod==='hi') ? CHUNK_VERT_HI : CHUNK_VERT_LO;
  const mat = (lod==='hi') ? groundMatHi : groundMatLo;
  const mesh = getPooledMesh(nVerts, mat);
  const chunkSize = (nVerts-1) * VERT_SPACING;
  mesh.position.set(cx * chunkSize, 0, cz * chunkSize);
  mesh.userData.cx = cx; mesh.userData.cz = cz; mesh.userData.lod = lod;
  // placeholder add to scene to allow raycasts while generating
  scene.add(mesh);

  const taskId = nextTaskId++;
  workerTasks.set(taskId, (result)=>{
    // fill geometry positions from worker result
    const posAttr = mesh.geometry.attributes.position;
    const arr = result.positions;
    // arr contains absolute x,y,z positions; we need to convert to local positions relative to mesh.position
    const half = (nVerts-1)/2 * VERT_SPACING;
    for(let i=0, j=0;i<posAttr.count;i++, j+=3){
      const lx = arr[j] - mesh.position.x;
      const ly = arr[j+1];
      const lz = arr[j+2] - mesh.position.z;
      posAttr.setX(i, lx);
      posAttr.setY(i, ly);
      posAttr.setZ(i, lz);
    }
    posAttr.needsUpdate = true;
    mesh.geometry.computeVertexNormals();
    // add simple collider data: bounding boxes per chunk (cheap)
    mesh.userData.aabb = new THREE.Box3().setFromObject(mesh);
    chunkMap.set(key, {mesh, cx, cz, lod});
    // add instanced trees for hi LOD
    if(lod==='hi') addTreesToChunk(cx,cz,mesh);
  });
  worker.postMessage({taskId, cx, cz, nVerts, vertSpacing: VERT_SPACING});
}

/* remove chunk */
function removeChunk(cx, cz){
  const key = chunkKey(cx,cz);
  const entry = chunkMap.get(key);
  if(!entry) return;
  // remove trees
  const inst = instancedTrees.get(key);
  if(inst){
    scene.remove(inst.instMesh); scene.remove(inst.trunkInst);
    instancedTrees.delete(key);
  }
  releaseMesh(entry.mesh);
  chunkMap.delete(key);
}

/* update chunks around player */
function updateChunks(){
  const chunkSizeHi = (CHUNK_VERT_HI-1) * VERT_SPACING;
  const px = Math.floor(controls.getObject().position.x / chunkSizeHi);
  const pz = Math.floor(controls.getObject().position.z / chunkSizeHi);
  const needed = new Set();
  for(let x = px - CHUNK_RADIUS; x <= px + CHUNK_RADIUS; x++){
    for(let z = pz - CHUNK_RADIUS; z <= pz + CHUNK_RADIUS; z++){
      const dist = Math.max(Math.abs(x-px), Math.abs(z-pz));
      const lod = (dist <= LOD_DIST) ? 'hi' : 'lo';
      const key = chunkKey(x,z);
      needed.add(key);
      if(!chunkMap.has(key)){
        requestChunk(x,z,lod);
      } else {
        const e = chunkMap.get(key);
        if(e.lod !== lod){
          removeChunk(x,z);
          requestChunk(x,z,lod);
        }
      }
    }
  }
  // remove distant
  for(const key of Array.from(chunkMap.keys())){
    if(!needed.has(key)){
      const [cx,cz] = key.split(',').map(Number);
      removeChunk(cx,cz);
    }
  }
}

/* ================ Trees (instancing) ================ */
function addTreesToChunk(cx, cz, mesh){
  const key = chunkKey(cx,cz);
  if(instancedTrees.has(key)) return;
  const instMesh = new THREE.InstancedMesh(treeGeom, treeMat, treeCountPerChunk);
  const trunkInst = new THREE.InstancedMesh(trunkGeom, trunkMat, treeCountPerChunk);
  instMesh.castShadow = true; trunkInst.castShadow = true;
  const dummy = new THREE.Object3D();
  const bbox = mesh.userData.aabb;
  for(let i=0;i<treeCountPerChunk;i++){
    // random position within chunk bounds
    const rx = bbox.min.x + Math.random() * (bbox.max.x - bbox.min.x);
    const rz = bbox.min.z + Math.random() * (bbox.max.z - bbox.min.z);
    // sample height by raycasting against mesh
    const localPos = new THREE.Vector3(rx, 1000, rz);
    const down = new THREE.Raycaster(localPos, new THREE.Vector3(0,-1,0));
    const hits = down.intersectObject(mesh, true);
    if(!hits.length) continue;
    const hy = hits[0].point.y;
    // skip water and steep slopes
    if(hy < WATER_LEVEL + 1) continue;
    const scale = 0.8 + Math.random()*0.8;
    dummy.position.set(rx, hy + 2.0*scale, rz);
    dummy.scale.set(scale, scale, scale);
    dummy.updateMatrix();
    instMesh.setMatrixAt(i, dummy.matrix);
    // trunk
    dummy.position.set(rx, hy + 0.6, rz);
    dummy.scale.set(0.6*scale, 0.6*scale, 0.6*scale);
    dummy.updateMatrix();
    trunkInst.setMatrixAt(i, dummy.matrix);
  }
  scene.add(instMesh); scene.add(trunkInst);
  instancedTrees.set(key, {instMesh, trunkInst});
}

/* ================ Water ================ */
const waterGeo = new THREE.PlaneBufferGeometry(10000,10000,1,1);
waterGeo.rotateX(-Math.PI/2);
const water = new THREE.Mesh(waterGeo, waterMat);
water.position.y = WATER_LEVEL;
water.receiveShadow = true;
scene.add(water);

/* ================ Collision: capsule vs terrain & AABB obstacles ================ */
/* We'll implement a simple capsule collider for the player and resolve penetration with chunk AABBs and terrain height sampling. */

function capsuleIntersectAABB(capsule, aabb){
  // capsule: {start:Vec3, end:Vec3, radius}
  // approximate by testing capsule line segment closest point to AABB
  const closest = new THREE.Vector3();
  aabb.clampPoint(capsule.start, closest);
  const d1 = closest.distanceToSquared(capsule.start);
  aabb.clampPoint(capsule.end, closest);
  const d2 = closest.distanceToSquared(capsule.end);
  return Math.min(d1,d2) <= capsule.radius * capsule.radius;
}

function resolvePlayerTerrain(playerPos){
  // raycast down to find terrain height under player
  const origin = playerPos.clone(); origin.y += 50;
  const ray = new THREE.Raycaster(origin, new THREE.Vector3(0,-1,0), 0, 200);
  // test only nearby chunk meshes
  const meshes = [];
  for(const v of chunkMap.values()){
    // quick frustum/AABB cull
    const aabb = v.mesh.userData.aabb;
    if(!aabb) continue;
    const dist = aabb.distanceToPoint(playerPos);
    if(dist > 200) continue;
    meshes.push(v.mesh);
  }
  const hits = ray.intersectObjects(meshes, true);
  if(hits.length){
    const groundY = hits[0].point.y;
    const targetY = groundY + PLAYER_HEIGHT;
    if(playerPos.y <= targetY){
      playerPos.y = targetY;
      velocity.y = 0;
      onGround = true;
      canJump = true;
    } else {
      onGround = false;
    }
  } else {
    onGround = false;
  }
}

/* ================ Init player pos ================ */
controls.getObject().position.set(0, 80, 0);

/* ================ Main loop ================ */
let prev = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min(0.05, (now - prev)/1000);
  prev = now;

  // movement input
  const forward = (keys.w - keys.s);
  const strafe = (keys.d - keys.a);
  sprint = keys.shift === 1;
  const speed = sprint ? 18 : 10;
  // local movement vector
  const dir = new THREE.Vector3();
  controls.getDirection(dir);
  dir.y = 0; dir.normalize();
  const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dir).normalize();
  const moveVec = new THREE.Vector3();
  moveVec.addScaledVector(dir, forward);
  moveVec.addScaledVector(right, strafe);
  if(moveVec.lengthSq() > 0) moveVec.normalize();

  // apply horizontal velocity smoothing
  const targetVel = moveVec.multiplyScalar(speed);
  velocity.x += (targetVel.x - velocity.x) * Math.min(1, 10 * dt);
  velocity.z += (targetVel.z - velocity.z) * Math.min(1, 10 * dt);

  // gravity
  velocity.y += GRAVITY * dt;

  // move player (kinematic)
  const deltaPos = velocity.clone().multiplyScalar(dt);
  controls.getObject().position.add(deltaPos);

  // collision with terrain
  resolvePlayerTerrain(controls.getObject().position);

  // simple collision with chunk AABBs (prevent walking through steep cliffs)
  const capsule = {
    start: controls.getObject().position.clone().add(new THREE.Vector3(0, -PLAYER_HEIGHT*0.5, 0)),
    end: controls.getObject().position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT*0.5, 0)),
    radius: PLAYER_RADIUS
  };
  for(const v of chunkMap.values()){
    const aabb = v.mesh.userData.aabb;
    if(!aabb) continue;
    if(capsuleIntersectAABB(capsule, aabb)){
      // simple push out along Y if penetrating from below/above
      const closest = aabb.clampPoint(controls.getObject().position.clone(), new THREE.Vector3());
      const dirOut = controls.getObject().position.clone().sub(closest);
      if(dirOut.length() < 0.001) dirOut.set(0,1,0);
      dirOut.normalize();
      controls.getObject().position.add(dirOut.multiplyScalar(0.5));
    }
  }

  // keep camera above water
  if(controls.getObject().position.y < WATER_LEVEL + PLAYER_HEIGHT) {
    controls.getObject().position.y = WATER_LEVEL + PLAYER_HEIGHT;
    velocity.y = 0;
    onGround = true;
  }

  // update chunks and trees
  updateChunks();

  // animate water
  water.material.opacity = 0.55 + Math.sin(now*0.001)*0.05;

  renderer.render(scene, camera);
}
animate();

/* ================ Resize ================ */
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>